---
title: Performance von NodeJs - Langsamer vergleich von Arrays //TODO
image:
  url: /images/blog/node-js-performance/node-js-performance.png
  alt: JavaScript-Code zum Bilden einer Differenz zwischen zwei Arrays
subtitle: //TODO
teaser: Durch Funktionen wie Array.filter() oder Array.some() kann man mit sehr wenig Code sehr mächtige Array-Operationen beschreiben. Die Gefahr dabei ist, dass man die Performance dabei außer Acht lässt.
date: 2024-09-03
authors:
  - fabian
---

Wir sind kürzlich auf ein Performance-Problem in NodeJs gestoßen. Wir wollten zwei große Log-Dateien (JSON) vergleichen, beide Dateien bestanden jeweils aus einem Array von ca 1.000.000 Objekten. Ziel war es, eine Differenz von den beiden Arrays zu bilden, um neue Einträge zu untersuchen. Normalerweise ist sowas eine Kleinigkeit, in JavaScript sind das wenige Zeilen Code. Gesagt, getan, doch als nach über einer Stunde das Script nicht fertig war, machten wir uns Gedanken.

## Mengen-Operationen in JavaScript

JavaScript brachte lange Zeit keine Mengen-Operationen von Haus aus mit. Erst seit Juni 2024 gibt es am "Set"-Objekt die Möglichkeit, eine Schnittmenge oder eine Differenz zwischen 2 Mengen zu bilden. Daher findet man im Internet oftmals noch Code, welcher nicht auf die Set-Klasse zurückgreift. Wir haben mehrer Optionen getestet:

### Option 1: Vergleichen mit Schleifen

```ts
const bigArray1 = Array.from({length: 200000}, (v, k) => ({id: k.toString()}));
const bigArray2 = Array.from({length: 200000}, (v, k) => ({id: (k / 2).toString()}));

// variant 1
const diff = bigArray1.filter(obj => !bigArray2.some(obj2 => obj2.id === obj.id));
// duration = ~ 120 s

// variant 2
const diff = [];
outerLoop:
    for (const array1Ele of bigArray1) {
        for (const array2Ele of bigArray2) {
            if (array1Ele.id === array2Ele.id) {
                continue outerLoop;
            }
        }
        diff.push(array1Ele);
    }
// duration = ~ 120 s
```

Zum testen benutzen wir zwei Arrays mit jeweils 200.000 Einträgen, welche jeweils Objekte mit einer eindeutigen Id sind. Die Arrays beinhalten also nicht die gleichen Objekte, es müssen also immer die Ids verglichen werden.
Die erste Variante war unser erste Ansatz zum bilden der Differenz. Es ist ein Ansatz aus der funktionalen Programmierung, er ist kurz, schnell verständlich und es wird wenig Speicher verbraucht. Der Nachteil der Variante ist, dass relativ viel Zeit benötigt wird. Wir haben zum testen ein klassisches Vergleichen der beiden Arrays mit O(n²) laufzeit getestet und sind auf ähnliche Zeiten gekommen. Wir ertrachten diese Variante nur als sinnvoll, wenn wenig Arbeitsspeicher zur Verfügung steht oder die beiden Arrays eine größe haben, bei denen die Performance egal ist.

### Option 2: Array.includes()
```ts
const bigArray2Ids = bigArray2.map((obj) => obj.id);
const diff = bigArray1.filter(obj => !bigArray2Ids.includes(obj.id));
// duration = ~ 80 s
```
Bei der zweiten Option haben wir Array.includes() benutzt, um zu prüfen, ob ein Objekt in dem Array vorhanden ist. Da includes die Objekt als Referenzen vergleichen würde, müssen wir auch hier die Ids benutzen. Includes darf von jeder JavaScript-Engine unterschiedlich implementiert werden, wir haben es getestet mit Node 22.7.0. Die Laufzeit verbessert sich etwas, dafür ist nun der Speicherbedarf höher, da wir ein zusätliches Array mit den Ids benötigen. Diese Variante ist unverständlicher als die erste Variante, der Laufzeit-Vorteil ist allerdings gering, daher ist diese Variante nicht empfehlenswert.

### Option 3: Set
```ts
const bigArray2StringifiedSet = new Set(bigArray2.map((obj) => JSON.stringify(obj)));
const bigArray1StringifiedSet = new Set(bigArray1.map((obj) => JSON.stringify(obj)));
const differenceStringified = Array.from(bigArray1StringifiedSet.difference(bigArray2StringifiedSet));
const diff = differenceStringified.map((obj) => JSON.parse(obj));
// duration = ~ 0.4 s
```

Seit Juni 2024 wird von fast allen modernen JavaScript-Engines "Set.difference()" unterstützt, so auch ab Node v22. Da auch hier Referenzen von den jeweiligen Objekten verglichen werden würden, benutzen wir JSON.stringify(), um vergleichbare Strings zu erzeugen. Der Haken hierdran ist, dass beide Objekte die gleichen Eigenschaften haben müssen, die gleiche Id reicht nicht aus. Hier stellen wir das erste mal einen großen Sprung in der Laufzeit fest, die Komplexität liegt wahrscheinlich bei O(n), der Speicherbedarf ist allerdings auch deutlich gestiegen, da wir beide Arrays nicht nur duplizieren, sondern auch als serialisierte Strings halten.

### Option 4: Objektfelder
```ts
const map = {};
for (const ele of bigArray2) {
    map[ele.id] = true;
}
const mapTimestamp = new Date();
const diff = bigArray1.filter(obj => !map[obj.id]);
// duration = ~ 0.07 s
```

Die mit Abstand schnellste Variante ist es, ein Objekt als Map zu benutzen. Hierbei erzeugen wir für jeden Key des einen Arrays ein Feld in unserer Map. Somit wird zusätlicher Speicher für die Map benötigt, allerdings nur in der Größe von "Anzahl der Elemente Array2 * Bytes pro Boolean). Beim vergleichen der Werte kann dann auf die Map zugegriffen werden, der Zugriff auf die Map hat eine Laufzeitkomplexität von O(1), somit hat das Filtern eine Komplexität von O(n). Nachteil ist der nicht Code, welcher nicht intuitiv erscheint, gerade für Programmierer, welche nicht aus der JavaScript-Welt kommen. Für Performantes vergleichen von zwei Arrays sollte allerdings diese Variante gewählt werden, solange genügend Arbeitsspeicher vorhanden ist.



### Fazit
Abschließend ist zu sagen, dass Vorteile in der Laufzeit nahezu immer Nachteile im Speicherbedarf bedeuten. Außerdem sind viele der Obenen gennanten Funktionen bei verschiedenen JavaScript-Engines unterschiedlich implementiert.


